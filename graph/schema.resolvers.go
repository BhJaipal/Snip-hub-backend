package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"backend/graph/model"
	"context"
	"errors"
	"fmt"
	"log"
	"regexp"

	"go.mongodb.org/mongo-driver/bson"
)

// SnipAdd is the resolver for the snipAdd field.
func (r *mutationResolver) SnipAdd(ctx context.Context, codeSnip model.SnipBox) (*model.Signal, error) {
	snipHub, _, err := snipHubDB()
	if err != nil {
		log.Fatal(err)
	}
	langList_ := langList()
	for i := 0; i < len(langList_); i++ {
		if langList_[i].LangName == codeSnip.LangName {
			langFind_, _ := langFind(langList_[i].LangName)
			for j := 0; j < len(langFind_.CodeBoxes); j++ {
				if langFind_.CodeBoxes[j].Title == codeSnip.CodeBox.Title {
					return &model.Signal{Status: 2, Message: "Snippet already exists"}, nil
				}
			}
			collection := snipHub.Collection(langList_[i].LangName)
			_, err := collection.InsertOne(context.Background(), bson.D{
				{Key: "title",Value: fmt.Sprintf("%v", codeSnip.CodeBox.Title)},
				{Key: "code", Value: fmt.Sprintf("%v", codeSnip.CodeBox.Code)}})
			if err != nil {
				log.Fatal(err)
			}
			return &model.Signal{Status: 0, Message: "Snippet added successfully"}, nil
		}
	}
	snipHub.CreateCollection(context.Background(), codeSnip.LangName)
	snipHub.Collection(codeSnip.LangName).InsertOne(context.Background(), bson.D{
				{Key: "title",Value: fmt.Sprintf("%v", codeSnip.CodeBox.Title)},
				{Key: "code", Value: fmt.Sprintf("%v", codeSnip.CodeBox.Code)}})
	return &model.Signal{Status: 1, Message: "new language added with snippet"}, nil
}

// LangList is the resolver for the langList field.
func (r *queryResolver) LangList(ctx context.Context) ([]*model.Language, error) {
	snipHub, ctxDb, err := snipHubDB()
	if err != nil {
		log.Fatal(err)
	}
	langSnips := []*model.Language{};
	langNames_ := langNames()
	for i := 0; i < len(langNames_); i++ {
		LangSnip := model.Language{LangName: langNames_[i], CodeBoxes: []*model.CodeBox{}}
		collection := snipHub.Collection(langNames_[i])
		cur, err := collection.Find(ctxDb, bson.D{})
		if err != nil { log.Fatal(err) }
		defer cur.Close(ctxDb)
		for cur.Next(ctxDb) {
			var result bson.D
			err2 := cur.Decode(&result)
			LangSnip.CodeBoxes = append(LangSnip.CodeBoxes, &model.CodeBox{Title: fmt.Sprintf("%v", result[1].Value), Code: fmt.Sprintf("%v", result[2].Value)})
			if err2 != nil { log.Fatal(err2) }
		}
		if len(LangSnip.CodeBoxes) != 0 {
			langSnips = append(langSnips, &LangSnip)
		}
		if err2 := cur.Err(); err2 != nil {
			log.Fatal(err)
		}
	}
	return langSnips, nil
}

// LangFind is the resolver for the langFind field.
func (r *queryResolver) LangFind(ctx context.Context, langName string) (*model.Language, error) {
	snipHub, ctxDb, err := snipHubDB()
	if err != nil {
		log.Fatal(err)
	}
	langNames_ := langNames()
	for i := 0; i < len(langNames_); i++ {
		if langNames_[i] != langName {
			continue
		}
		LangSnip := model.Language{LangName: langNames_[i], CodeBoxes: []*model.CodeBox{}}
		collection := snipHub.Collection(langNames_[i])
		cur, err := collection.Find(ctxDb, bson.D{})
		if err != nil { log.Fatal(err) }
		defer cur.Close(ctxDb)
		for cur.Next(ctxDb) {
			var result bson.D
			err2 := cur.Decode(&result)
			LangSnip.CodeBoxes = append(LangSnip.CodeBoxes, &model.CodeBox{Title: fmt.Sprintf("%v", result[1].Value), Code: fmt.Sprintf("%v", result[2].Value)})
			if err2 != nil { log.Fatal(err2) }
		}
		if err2 := cur.Err(); err2 != nil {
			log.Fatal(err)
		}
		return &LangSnip, nil
	}
	return &model.Language{LangName: "Unknown", CodeBoxes: []*model.CodeBox{}}, errors.New("language not found")
}

// TitleFind is the resolver for the titleFind field.
func (r *queryResolver) TitleFind(ctx context.Context, title string) ([]*model.Language, error) {
	snipHub, ctxDb, err := snipHubDB()
	if err != nil {
		log.Fatal(err)
	}
	langNames_ := langNames()
	langSnips := []*model.Language{};
	for i := 0; i < len(langNames_); i++ {
		LangSnip := model.Language{LangName: langNames_[i], CodeBoxes: []*model.CodeBox{}}
		collection := snipHub.Collection(langNames_[i])
		cur, err := collection.Find(ctxDb, bson.D{})
		if err != nil { log.Fatal(err) }
		defer cur.Close(ctxDb)
		for cur.Next(ctxDb) {
			var result bson.D
			err2 := cur.Decode(&result)
			match1 := regexp.MustCompile("(?i)"+ title).Match([]byte(fmt.Sprintf("%v", result[1].Value)))
			match2 := regexp.MustCompile("(?i)"+ fmt.Sprintf("%v", result[2].Value)).Match([]byte(title))
			if match1 || match2 {
				LangSnip.CodeBoxes = append(LangSnip.CodeBoxes, &model.CodeBox{Title: fmt.Sprintf("%v", result[1].Value), Code: fmt.Sprintf("%v", result[2].Value)})
			}
			if err2 != nil { log.Fatal(err2) }
		}
		if err2 := cur.Err(); err2 != nil {
			log.Fatal(err)
		}
		langSnips = append(langSnips, &LangSnip)
	}
	return langSnips, bson.ErrDecodeToNil
}

func (r *queryResolver) LangNames(ctx context.Context) ([]string, error) {
	snipHub, ctxDb, err := snipHubDB()
	if err != nil {
		fmt.Printf("Error: %v\n", err)
	}
	languages, err2 := snipHub.ListCollectionNames(ctxDb, bson.D{})
	if err2 != nil {
		fmt.Printf("Error: %v\n", err2)
	}
	return languages, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
